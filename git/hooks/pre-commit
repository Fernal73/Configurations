#!/usr/bin/env bash
if [[ -f .git/hooks/pre-commit ]]; then
  if ! .git/hooks/pre-commit "$@"; then
    echo 'Local pre-commit hook failed, please see output above'
    exit 1
  fi
fi
require() {
  hash "$@" || exit 127
}
optimize() {
  file="$1"
  mode=$(stat -c "%a" "$file")
  jpegoptim -f "$file" &&
    hash=$(git hash-object -w "${file}") &&
    # Add it back to index \
    git update-index --add --cacheinfo "100${mode}" "$hash" "$file" || exit 1
  return $?
}
require ggshield git shch parallel jpegoptim stat find head tidy rm wscheck file mktemp readlink

declare -i ret=0
# Regexp for grep to only choose sh file extension for checking
exts="\.sh$"
git diff --cached --name-only --diff-filter=ACMR | grep $exts | parallel "shch {}"
ret=$?
cmd="git diff --cached --name-only --diff-filter=ACMR | grep -v '\.'"
readarray -t files < <(eval "$cmd")
ret=$((ret + $?))
for file in "${files[@]}"; do
  if test -x "$file"; then
    shch "$file"
    ret=$((ret + $?))
  fi
done
cmd="git diff --cached --name-only --diff-filter=ACMR | grep '^\.'"
readarray -t files < <(eval "$cmd")
ret=$((ret + $?))
for file in "${files[@]}"; do
  if test -x "$file"; then
    shch "$file"
    ret=$((ret + $?))
  fi
done
exts="'.*(\.jpg$|\.jpeg$)'"
cmd="git diff --cached --name-only --diff-filter=ACMR | grep -o -E $exts"
readarray -t files < <(eval "$cmd")
ret=$((ret + $?))
for file in "${files[@]}"; do
  optimize "$file"
  ret=$((ret + $?))
done

declare -r configFileName="tidy.config"
configFilePath="$(readlink -f "$configFileName")"

# Regexp for grep to only choose some file extensions for formatting
exts="\.xml$"

# The formatter to use
formatter=$(which tidy)

# Check availability of the formatter
if [ -z "$formatter" ]; then
  echo 1>&2 "$formatter not found. Pre-commit formatting will not be done."
  exit 0
fi

cmd="git diff --cached --name-only --diff-filter=ACMR | grep $exts"
readarray -t files < <(eval "$cmd")
ret=$((ret + $?))

# Format staged files
for file in "${files[@]}"; do
  # don't format empty files
  if test -s "$file"; then
    echo "Formatting ${file}..."
    # Get the file from index
    git show ":$file" >"${file}.tmp"
    # Format it
    eval "$formatter -config $configFilePath -quiet -xml -m -i ${file}.tmp &>/dev/null"
    ret=$((ret + $?))
    # Create a blob object from the formatted file
    hash=$(git hash-object -w "${file}.tmp")
    # Add it back to index
    mode=$(stat -c "%a" "$file")
    git update-index --add --cacheinfo "100${mode}" "$hash" "$file"
    git cat-file -p "$hash" >"${file}"
    rm "${file}.tmp"
  fi
done

istextfile() {
  if (file "$1" | grep 'ASCII' &>/dev/null); then
    return 0
  fi
  return 1
}

isxmlfile() {
  if (file "$1" | grep 'XML' &>/dev/null); then
    return 0
  elif (file "$1" | grep 'HTML' &>/dev/null); then
    return 0
  elif (file "$1" | grep 'SGML' &>/dev/null); then
    return 0
  else
    return 1
  fi
}

# If no files left in index after formatting - fail
# i.e., if files are similar after changes
cmd="git diff --cached --name-only"
readarray -t files < <(eval "$cmd")
for file in "${files[@]}"; do
  if istextfile "$file"; then
    declare -i wsout=0
    echo "Checking ${file} for whitespace..."
    tmp="$(mktemp)"
    if isxmlfile "$file"; then
      wscheck --exclude WSC002 WSC003 --checkstyle "$tmp" -- "$file"
      wsout=$?
    else
      wscheck --checkstyle "$tmp" -- "$file"
      wsout=$?
    fi
    ret=$((ret + wsout))
    if test "$wsout" -ne 0; then
      mv "$tmp" "${file}.wsout"
    else
      rm "$tmp"
    fi
  fi
done

if [ ${#files[@]} -eq 0 ]; then
  echo 1>&2 "No files changed after processing..."
  ret=$((ret + 1))
fi

ggshield secret scan pre-commit "$@"
ret=$((ret + $?))
exit "$ret"
